#!/usr/bin/env bash

# Manage installed apps in apps.toml
function app() {
	uv run "${DOTPATH}/scripts/app.py" "$@"
}

# Run aerials.py
function aerials() {
	if [[ $# -eq 0 ]]; then
		uv run "${DOTPATH}/scripts/aerials.py" -d -y
	else
		uv run "${DOTPATH}/scripts/aerials.py" "$@"
	fi
}

# Run bootstrap.sh
function bootstrap() {
	bash "${DOTPATH}/bootstrap.sh" -y
}

function chrome() {
	uvx --with "selenium" python -c "from selenium import webdriver; driver = webdriver.Chrome(); input('Press Enter to exit...')"
}

function boo() {
	ghostty +boo
}

function compresspdf() {
	# from https://superuser.com/a/1217306/1280839
	if [[ $# -lt 2 || $1 == "-h" || $1 == "--help" ]]; then
		echo 'Usage: compresspdf [input file] [output file] [screen|ebook|printer|prepress]'
		if [[ $1 == "-h" || $1 == "--help" ]]; then
			return 0
		fi
		return 1
	else
		gs -sDEVICE=pdfwrite -dNOPAUSE -dQUIET -dBATCH -dPDFSETTINGS=/"${3:-"screen"}" -dCompatibilityLevel=1.4 -sOutputFile="$2" "$1"
	fi
}

# Export environment variables from .env file (TIL this is not the same as `source .env`)
function exportenv() {
	export $(grep -v '^#' "${1:-".env"}" | xargs)
}

# Start screensaver.
function ss() {
	open -a ScreenSaverEngine
}

# Show battery percentage.
function battery() {
	pmset -g batt | grep -E "([0-9]+\%).*" -o --colour=auto | cut -f1 -d';'
	pmset -g batt | grep -E "([0-9]+\%).*" -o --colour=auto | cut -f3 -d';'
}

# Relaunch core audio when it stops working without having to restart macOS
function audiokill() {
	# sudo killall coreaudiod
	sudo pkill coreaudiod -i
}

# `o` with no arguments opens the current directory, otherwise opens the given location
function o() {
	if [[ $# -eq 0 ]]; then
		open .
	else
		open "$@"
	fi
}

# `c` with no arguments opens Cursor in the current directory, otherwise opens at the given location
function c() {
	if [[ $# -eq 0 ]]; then
		open -a "Cursor" -- .
	else
		open -a "Cursor" -- "$@"
	fi
}

# Case-insensitively sort keys and arrays in JSON files in place
function jsort() {
	local mode="" target="." sort_arrays=0 no_ignore=0

	_jsort_usage() {
		echo "Case-insensitively sort keys and arrays in JSON files in place." >&2
		echo "" >&2
		echo "Usage: jsort [OPTIONS] <COMMAND>" >&2
		echo "" >&2
		echo "Commands:" >&2
		echo "  fmt     Format the given JSON files or directories" >&2
		echo "  check   Check if the given JSON files or directories need formatting" >&2
		echo "" >&2
		echo "Options:" >&2
		echo "  -a, --sort-arrays    Sort array elements" >&2
		echo "  -i, --no-ignore      Do not ignore files in .gitignore" >&2
		echo "  -h, --help           Print help" >&2
	}

	while [[ $# -gt 0 ]]; do
		case "$1" in
			fmt|check)
				mode="$1"
				shift
				;;
			-a|--sort-arrays)
				sort_arrays=1
				shift
				;;
		-i|--no-ignore)
			no_ignore=1
			shift
			;;
		-h|--help)
			_jsort_usage
			return 0
			;;
		-*)
			_jsort_usage
			return 2
			;;
			*)
				if [[ "${target}" == "." ]]; then
					target="$1"
				else
					_jsort_usage
					return 2
				fi
				shift
				;;
		esac
	done

	if [[ -z "${mode}" ]]; then
		_jsort_usage
		return 2
	fi

	if [[ ! -e "${target}" ]]; then
		echo "jsort: no such file or directory: ${target}" >&2
		return 1
	fi

	if ! command -v yq &>/dev/null; then
		echo "jsort: yq is required but was not found in PATH" >&2
		return 127
	fi

	# Build expression based on flags
	local expr
	if [[ ${sort_arrays} -eq 1 ]]; then
		expr='
			(... | select(tag == "!!seq")) |= sort_by((select(tag == "!!str") | downcase) // .)
			|
			(... | select(tag == "!!map")) |= sort_by(key | downcase)
		'
	else
		expr='
			(... | select(tag == "!!map")) |= sort_by(key | downcase)
		'
	fi

	# Determine number of parallel jobs
	local jobs
	jobs=$(sysctl -n hw.ncpu 2>/dev/null)
	if [[ -z "${jobs}" || ! "${jobs}" =~ ^[0-9]+$ ]]; then
		jobs=4
	fi
	if [[ ${jobs} -lt 1 ]]; then
		jobs=1
	fi

	# Temporary files
	local result_file expr_file
	result_file=$(mktemp) || return 1
	expr_file=$(mktemp) || { rm -f "${result_file}"; return 1; }
	trap "rm -f '${result_file}' '${expr_file}'" EXIT
	printf '%s' "${expr}" >"${expr_file}"

	# Helper function to process a single file
	_jsort_process_file() {
		local file="$1" mode="$2" result_file="$3" expr_file="$4" tmp_file expr

		expr=$(cat "${expr_file}")
		tmp_file=$(mktemp) || { echo "error:${file}" >>"${result_file}"; return 1; }
		if ! yq -P -o=json "${expr}" "${file}" >"${tmp_file}" 2>/dev/null; then
			rm -f "${tmp_file}"
			echo "error:${file}" >>"${result_file}"
			return 1
		fi

		if cmp -s "${tmp_file}" "${file}" 2>/dev/null; then
			rm -f "${tmp_file}"
			echo "unchanged:${file}" >>"${result_file}"
		else
			if [[ ${mode} == "fmt" ]]; then
				mv "${tmp_file}" "${file}" || { rm -f "${tmp_file}"; echo "error:${file}" >>"${result_file}"; return 1; }
			else
				rm -f "${tmp_file}"
			fi
			echo "formatted:${file}" >>"${result_file}"
		fi
	}

	# Process files
	if [[ -d "${target}" ]]; then
		find "${target}" -type f -name '*.json' -print0 | xargs -0 -P "${jobs}" -I {} bash -c '
			file="$1"
			mode="$2"
			result_file="$3"
			expr_file="$4"
			no_ignore="$5"
			# Skip if file is ignored by .gitignore (unless --no-ignore is set)
			if [[ ${no_ignore} -eq 0 ]] && command -v git &>/dev/null; then
				if git check-ignore -q "${file}" 2>/dev/null; then
					exit 0
				fi
			fi
			expr=$(cat "${expr_file}")
			tmp_file=$(mktemp) || { echo "error:${file}" >>"${result_file}"; exit 1; }
			if ! yq -P -o=json "${expr}" "${file}" >"${tmp_file}" 2>/dev/null; then
				rm -f "${tmp_file}"
				echo "error:${file}" >>"${result_file}"
				exit 1
			fi
			if cmp -s "${tmp_file}" "${file}" 2>/dev/null; then
				rm -f "${tmp_file}"
				echo "unchanged:${file}" >>"${result_file}"
			else
				if [[ ${mode} == "fmt" ]]; then
					mv "${tmp_file}" "${file}" || { rm -f "${tmp_file}"; echo "error:${file}" >>"${result_file}"; exit 1; }
				else
					rm -f "${tmp_file}"
				fi
				echo "formatted:${file}" >>"${result_file}"
			fi
		' _ {} "${mode}" "${result_file}" "${expr_file}" "${no_ignore}"
	else
		# For single file, check .gitignore unless --no-ignore is set
		if [[ ${no_ignore} -eq 0 ]] && command -v git &>/dev/null; then
			if git check-ignore -q "${target}" 2>/dev/null; then
				echo "jsort: file is ignored by .gitignore (use --no-ignore to process it)" >&2
				return 0
			fi
		fi
		_jsort_process_file "${target}" "${mode}" "${result_file}" "${expr_file}"
	fi

	# Count results
	local formatted_count unchanged_count error_count total_count
	formatted_count=$(grep -c "^formatted:" "${result_file}" 2>/dev/null)
	formatted_count=${formatted_count:-0}
	unchanged_count=$(grep -c "^unchanged:" "${result_file}" 2>/dev/null)
	unchanged_count=${unchanged_count:-0}
	error_count=$(grep -c "^error:" "${result_file}" 2>/dev/null)
	error_count=${error_count:-0}
	total_count=$((formatted_count + unchanged_count + error_count))

	if [[ ${total_count} -eq 0 ]]; then
		if [[ ${mode} == "check" ]]; then
			echo "No files linted"
		else
			echo "No files formatted"
		fi
		return 0
	fi

	if [[ ${error_count} -gt 0 ]]; then
		echo "Files that had errors:" >&2
		grep "^error:" "${result_file}" 2>/dev/null | sed 's/^error://' >&2
		echo >&2
		echo "jsort: ${error_count} file(s) had errors" >&2
	fi

	if [[ ${mode} == "check" && ${formatted_count} -gt 0 ]]; then
		echo "Files that would be formatted:" >&2
		grep "^formatted:" "${result_file}" 2>/dev/null | sed 's/^formatted://' >&2
		echo >&2
		local word=$([[ ${formatted_count} -eq 1 ]] && echo "file" || echo "files")
		echo "${formatted_count} ${word} would be formatted" >&2
		return 1
	fi

	if [[ ${formatted_count} -gt 0 ]]; then
		local word=$([[ ${formatted_count} -eq 1 ]] && echo "file" || echo "files")
		echo "${formatted_count} ${word} formatted"
	fi
	if [[ ${unchanged_count} -gt 0 ]]; then
		local word=$([[ ${unchanged_count} -eq 1 ]] && echo "file" || echo "files")
		echo "${unchanged_count} ${word} did not need formatting"
	fi

	[[ ${error_count} -eq 0 ]]
}

# Create a new directory and enter it.
function mkd() {
	mkdir -p "$@" && cd "${_}" || exit 1
}

# Determine size of a file or total size of a directory.
function fs() {
	if du -b /dev/null >/dev/null 2>&1; then
		local arg=-sbh
	else
		local arg=-sh
	fi
	if [[ -n $* ]]; then
		du "${arg}" -- "$@"
	else
		du "${arg}" .[^.]* ./*
	fi
}

# Create a data URL from a file.
function dataurl() {
	local mimeType
	mimeType=$(file -b --mime-type "$1")
	if [[ ${mimeType} == text/* ]]; then
		mimeType="${mimeType};charset=utf-8"
	fi
	echo "data:${mimeType};base64,$(openssl base64 -in "$1" | tr -d '\n')"
}

# Weather checker
function weather {
	curl -s "wttr.in/${1-lisbon}?format=3"
}

# Animated globe ASCII art
function animate() {
	local animation=${1:-movglobe}
	local speed=${2:-9600}
	# More examples: http://artscene.textfiles.com/vt100/
	curl -s "http://artscene.textfiles.com/vt100/${animation}.vt" | pv -q -L "${speed}"
}

function starwars() {
	telnet towel.blinkenlights.nl
}

# Cursor jump
function jc {
	if [[ -z $1 || $1 == "." ]]; then
		open -a "Cursor" -- .
	else
		open -a "Cursor" -- "$(j "$1")"
	fi
}

# Create a private github repo on github and copy the current repo to it under the remote 'personal'
function copy-repo-to-personal() {
	REPO=$(basename "${PWD##*/}")
	GHUSER=$(git config --get github.user)
	GHTOKEN=$(git config --get github.token)
	if [[ -z ${GHUSER} || -z ${GHTOKEN} ]]; then
		echo "ERROR: No Github user or token found."
	else
		curl -u "${GHUSER}":"${GHTOKEN}" https://api.github.com/user/repos -d {\\\"name\\\":\\\""${REPO}"\\\"\\,\\\"private\\\":\\\"true\\\"} --fail
		git remote add personal git@github.com:"${GHUSER}"/"${REPO}".git
		git push personal main
	fi
}

# Clone remote branches to local repo, fetch all commits, and fast-forward new commits.
function git-update() {
	# https://stackoverflow.com/a/10312587/4760185
	git branch -r | grep -v '\->' | while read -r remote; do git branch --track "${remote#origin/}" "${remote}"; done
	git fetch --all
	git pull --all

	# https://stackoverflow.com/a/9076361/4760185
	REMOTES="$*"
	if [[ -z ${REMOTES} ]]; then
		REMOTES=$(git remote)
	fi
	REMOTES=$(echo "${REMOTES}" | xargs -n1 echo)
	CLB=$(git rev-parse --abbrev-ref HEAD)
	echo "${REMOTES}" | while read -r REMOTE; do
		git remote update "${REMOTE}"
		git remote show "${REMOTE}" -n |
			awk '/merges with remote/{print $5" "$1}' |
			while read -r RB LB; do
				ARB="refs/remotes/${REMOTE}/${RB}"
				ALB="refs/heads/${LB}"
				NBEHIND=$(($(git rev-list --count "${ALB}".."${ARB}" 2>/dev/null) + 0))
				NAHEAD=$(($(git rev-list --count "${ARB}".."${ALB}" 2>/dev/null) + 0))
				if [[ ${NBEHIND} -gt 0 ]]; then
					if [[ ${NAHEAD} -gt 0 ]]; then
						echo " branch ${LB} is ${NBEHIND} commit(s) behind and ${NAHEAD} commit(s) ahead of ${REMOTE}/${RB}. could not be fast-forwarded"
					elif [[ ${LB} == "${CLB}" ]]; then
						echo " branch ${LB} was ${NBEHIND} commit(s) behind of ${REMOTE}/${RB}. fast-forward merge"
						git merge -q "${ARB}"
					else
						echo " branch ${LB} was ${NBEHIND} commit(s) behind of ${REMOTE}/${RB}. resetting local branch to remote"
						git branch -f "${LB}" -t "${ARB}" >/dev/null
					fi
				fi
			done
	done
}
